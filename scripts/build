#!/bin/sh

# if the binary package already exists, do nothing
[ -f "$2" ] && exit 0

export LANG="C"
export LC_ALL="C"

TODAY="$(date +%d%m%Y)"
BASE_DIR="$(pwd)"
SYSROOT="$BASE_DIR/sysroot"
MAKE="make -j $(grep ^processor /proc/cpuinfo | wc -l)"
BUILD_DIR_SIZE="4G"
UID="$(id -u)"
ARCH="$(uname -m)"

# prepend PATH with BASE_DIR, to override *-config scripts
export PATH="$BASE_DIR:$PATH"

# decide which compiler to use
if [ -f "$SYSROOT/bin/musl-gcc" ]
then
	export REALGCC="gcc"
	export CC="$SYSROOT/bin/musl-gcc"
else
	export CC="gcc"
fi

# decide which compiler and linker flags to use
CFLAGS="-g \
        -Os \
        -fomit-frame-pointer \
        -ffunction-sections \
        -fdata-sections \
        -fmerge-all-constants \
        -pipe"
LDFLAGS="-Wl,-gc-sections \
         -Wl,--sort-common"
case "$ARCH" in
	i?86)
		CFLAGS="-march=i486 -mtune=i686 $CFLAGS"
		;;
	*)
		CFLAGS="-mtune=generic $CFLAGS"
		;;
esac
export CFLAGS
export LDFLAGS

# override pkg-config's directories with those under SYSROOT
export PKG_CONFIG="$BASE_DIR/pkg-config"
export PKG_CONFIG_PATH="$SYSROOT/lib/pkgconfig"
export PKG_CONFIG_LIBDIR="/lib/pkgconfig"

# include the build script - if no version is specified, assume it's a daily
# snapshot
PKG_VER="$TODAY"
PKG_SRCS=""
. "./rules/$1/build"

echo "> $1 $PKG_VER, $(date -u)"

# create a temporary directory for the building process and mount a tmpfs file
# system on it (to speed up building) if possible
build_dir="$(mktemp -d -p "$BASE_DIR")"
[ 0 -eq $UID ] && mount -t tmpfs \
                        -o size="$BUILD_DIR_SIZE" \
                        "build_$1" \
                        "$build_dir"

if [ -n "$PKG_SRCS" ]
then
	[ ! -d "sources/$1" ] && mkdir "sources/$1"
	cd "sources/$1"

	for i in $PKG_SRCS
	do
		case "$i" in
			# for VCS snapshots, clone without history and create a lzip-compressed
			# tar archive
			*.git)
				dest="$1-git$TODAY.tar.lz"
				if [ ! -f "$dest" ]
				then
					echo "> Cloning $i"
					git clone --depth 1 "$i" "$1-git$TODAY"
					[ 0 -eq $? ] && tar -c "$1-git$TODAY" |
					                lzip --best > "$dest"
					rm -rf "$1-git$TODAY"
				fi
				;;

			*/hg)
				dest="$1-hg$TODAY.tar.lz"
				if [ ! -f "$dest" ]
				then
					echo "> Cloning $i"
					hg clone "$i" "$1-hg$TODAY"
					[ 0 -eq $? ] && tar -c "$1-hg$TODAY" | lzip --best > "$dest"
					rm -rf "$1-hg$TODAY"
				fi
				;;

			svn://*)
				dest="$1-svn$TODAY.tar.lz"
				if [ ! -f "$dest" ]
				then
					echo "> Cloning $i"
					svn co "$i" "$1-svn$TODAY"
					[ 0 -eq $? ] && tar -c "$1-svn$TODAY" |
					                lzip --best > "$dest"
					rm -rf "$1-svn$TODAY"
				fi
				;;

			http://*|https://*|ftp://*)
				dest="$(echo ${i##*/} | cut -f 1 -d ?)"
				if [ ! -f "$dest" ]
				then
					echo "> Downloading $i"
					wget -O "$dest" "$i"
				fi
				;;
		esac

		# create a symlink to the downloaded file under the build directory
		ln -s "$(pwd)/$dest" "$build_dir/"
	done
fi

# extract all archives under the build directory
cd "$build_dir"
for i in $(ls *.tar* 2>/dev/null)
do
	echo "> Extracting $i"
	tar -xavf "$i"
done

# switch to the sources directory, if there is any
for i in *
do
	case "$i" in
		*-*|"$1")
			[ ! -d "$i" ] && continue
			cd "$i"
			break
			;;

		*)
			continue
			;;
	esac
done

# patch the sources
for i in "$BASE_DIR/rules/$1"/*
do
	case "$i" in
		*.patch|*.diff)
			echo "> Applying $i"
			patch -p 1 < "$i"
			;;
	esac
done

# updated autoconf files
if [ -f ./configure ] || [ -f ./autogen.sh ]
then
	echo "> Updating build system files"
	cp -vf /usr/share/misc/config.guess .
	cp -vf /usr/share/misc/config.sub .
fi

# build the package; replace TMPDIR with the temporary directory path because
# at least one package (FFmpeg) tries to run stuff from it, while some distros
# mount it noexec
echo "> Building"
export TMPDIR="$build_dir"
build

# install the build output to a directory
install_root="$(mktemp -d -p "$build_dir")"
echo "> Installing to $install_root"
package "$install_root"

# create wrappers for *-config scripts, which prepend all paths with SYSROOT
for i in $(ls "$install_root/bin"/*-config 2>/dev/null)
do
	name="$(basename "$i")"
	echo "#!/bin/sh
\"$SYSROOT/bin/$name\" \"\$@\" | \\
sed -e s~'-L/lib'~\"-L$SYSROOT/lib\"~g \\
    -e s~'-I/include'~\"-I$SYSROOT/include\"~g \\
    -e s~'-I/lib'~\"-I$SYSROOT/lib\"~g" > "$BASE_DIR/$name"
	chmod 755 "$BASE_DIR/$name"
done

# if the package has pkg-config files, create a generic wrapper for pkg-config
# as well, which also forces "--static"
if [ -d "$install_root/lib/pkgconfig" ] && [ ! -f "$BASE_DIR/pkg-config" ]
then
	echo "#!/bin/sh
output=\"\$($(which pkg-config) --static \"\$@\")\"
code=\$?
[ 0 -ne \$code ] && exit \$code
echo -n \"\$output\" | sed -e s~'-I/include'~\"-I$SYSROOT/include\"~g \\
                         -e s~'-L/lib'~\"-L$SYSROOT/lib\"~g \\
                         -e s~'-I/lib'~\"-I$SYSROOT/lib\"~g \\
                         -e s~'^/share'~\"$SYSROOT/share\"~g
exit 0" > "$BASE_DIR/pkg-config"
	chmod 755 "$BASE_DIR/pkg-config"
fi

# copy the raw package to the system root
cp -avr "$install_root"/* "$SYSROOT/"

# run all post-installation hooks
cd "$install_root"
for i in "$BASE_DIR/hooks"/*
do
	. "$i"
	echo "> Running post-install hook: $HOOK_NAME"
	run "$1"
done

# copy the processed package to the system root, to replace modified files (e.g
# stripped executables)
cp -vrp "$install_root"/* "$SYSROOT/"

# generate an archive containing the processed package
echo "> Creating $2"
cd "$BASE_DIR"
tar -C "$install_root" -c . | lzip --best > "$2"

# clean up
echo "> Cleaning up"
[ 0 -eq $UID ] && umount -l "$build_dir"
rm -rf "$build_dir"
